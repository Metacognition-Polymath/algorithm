/**
 * 아래 그림과 같은 이진트리를 전위순회와 후위순회를 연습해보세요.
 *    1
 *   / \
 *  2   3
 * / \ / \
 * 4 5 6 7
 * 전위순회 출력 : 1, 2, 4, 5, 3, 6, 7
 * 중위순회 출력 : 4, 2, 5, 1, 6, 3, 7
 * 후위순회 출력 : 4, 5, 2, 6, 7, 3, 1
 */

/**
 * 내 풀이
 * 트리를 만들고 그 다음 순회하면서 출력하는 걸까?
 * 바로 풀이 영상을 보자
 *
 * 강의 해설
 * 트리?
 * 나무를 거꾸로 세워놓은 모양
 * 이진 트린 : 두 개씩
 * - 왼쪽 자식, 오른쪽 자식
 * 시작점 : root
 * 2진 트리
 * - 왼쪽 자식 : 부모 * 2
 * - 오른쪽 자식 : 부모 * 2 + 1
 *
 * 용어 정리
 * - root : 부모
 * - edge(간선) : 부모에서 뻣어 나가는 선
 *
 * 깊이 우선 탐색
 * root node에서
 * - 계속 파고 들어가다가 막히면 되돌아와서 안가봤던 길로 감
 * - 다 가보면 다시 뒤돌아가서 안가본 곳이 나타날 때 까지 백
 *
 * 전위 순회 출력 순서
 * - 부모 -> 왼쪽 -> 오른쪽
 * - 1 2 4 5 3 6 7
 * 중위 순회
 * - 왼쪽 -> 부모 -> 오른쪽
 * - (1) (2) 4 2 5 1 (3) 6 3 7
 * - 4 2 5 1 6 3 7
 * 후위 순회
 * - 왼쪽 -> 오른쪽 -> 부모
 * - (1) (2) 4 5 2 (1) (3) 6 7 3 1
 * - 4 5 2 6 7 3 1
 *
 * 부모를 기준으로 부모가 제일 먼저 : 전위 순회
 * 부모가 중간 : 중위 순회
 * 부모가 제일 마지막 : 후위 순회
 *
 * v : vertex : 정점
 *
 * 중위 순회를 스택 프레임으로 그려보자
 * stack : [D(1), D(2), D(4), D(8)]
 * D(8)은 바로 return 돼서 pop 됨
 * 그리고 D(4)로 돌아가서 이어서 실행하는데
 * 그 다음라인에 console.log()가 있어서 출력 -> ///////// 4
 * 그리고 이어서 D(4)의 다음라인에서 D(9)를 스택에 넣음
 * stack : [D(1), D(2), D(4), D(9)]
 * D(9)는 if조건에 의해 바로 pop
 * 그리고 D(4)는 이어서 실행되다가 더 실행될게 없으니 끝
 * stack : [D(1), D(2)]
 * D(2)가 이어서 실행 -> console.log -> /////////// 2
 * 이어서 D(2)의 마지막에서 D(5)를 호출
 * stack : [D(1), D(2) - 마지막, D(5)]
 * D(5)가 D(10)을 호출
 * stack : [D(1), D(2) - 마지막, D(5), D(10)]
 * D(10)은 바로 끝남
 * stack : [D(1), D(2) - 마지막, D(5)]
 * D(5)는 이어서 실행되는데 console.log이므로 -> ///////// 5
 * D(5)의 마지막에서 D(11)을 호출
 * stack : [D(1), D(2) - 마지막, D(5) - 마지막, D(11)]
 * D(11)은 바로 끝남
 * stack : [D(1), D(2) - 마지막, D(5) - 마지막]
 * D(5)도 더 이상 실행할게 없어서 종료
 * stack : [D(1), D(2) - 마지막]
 * D(2)도 더 이상 실행할게 없어서 종료
 * stack : [D(1)]
 * D(1)이 이어서 실행 -> console.log -> ////////////// 1
 * D(1)의 마지막에서 D(3)을 호출
 * stack : [D(1) - 마지막, D(3)]
 * D(3)은 D(6)을 호출
 * stack : [D(1) - 마지막, D(3), D(6)]
 * D(6)은 D(12)를 호출
 * stack : [D(1) - 마지막, D(3), D(6), D(12)]
 * D(12)는 if에 의해 바로 종료
 * stack : [D(1) - 마지막, D(3), D(6)]
 * D(6)이 이어서 실행 -> console.log -> ////////////// 6
 * D(6)의 마지막에서 D(13)을 호출
 * stack : [D(1) - 마지막, D(3), D(6) - 마지막, D(13)]
 * D(13)은 if에 의해 바로 종료
 * stack : [D(1) - 마지막, D(3), D(6) - 마지막]
 * D(6)은 더 이상 실행할게 없으니 종료
 * stack : [D(1) - 마지막, D(3)]
 * D(3)이 이어서 실행 -> console.log -> ////////////// 3
 * D(3)의 마지막에서 D(7)을 호출
 * stack : [D(1) - 마지막, D(3) - 마지막, D(7)]
 * D(7)은 D(14)를 호출
 * stack : [D(1) - 마지막, D(3) - 마지막, D(7), D(14)]
 * D(14)는 if에 의해 바로 종료
 * stack : [D(1) - 마지막, D(3) - 마지막, D(7)]
 * D(7)이 이어서 실행 -> console.log -> ////////////// 7
 * D(7)의 마지막에서 D(15)를 호출
 * stack : [D(1) - 마지막, D(3) - 마지막, D(7) - 마지막, D(15)]
 * D(15)는 if에 의해 바로 종료
 * stack : [D(1) - 마지막, D(3) - 마지막, D(7) - 마지막]
 * D(7)은 더 이상 실행할게 없어서 종료
 * stack : [D(1) - 마지막, D(3) - 마지막]
 * 나머지들도 더 이상 실행할게 없으니 순차적으로 스택에서 pop 됨
 * stack : [D(1) - 마지막]
 * stack : []
 *
 * 중위 순회 출력 결과
 * 4, 2, 5, 1, 6, 3, 7
 */
function solution(n) {
  let answer = "";
  function DFS(v) {
    if (v > 7) {
      // 멈추는 지점
      return;
    } else {
      // 항상 재귀를 작성할 때 else에서 console을 찍어보자
      // 재귀가 뻣어 나가는 지점
      DFS(v * 2); // 왼쪽 자식으로 먼저 가고, 왼쪽 자식이 일이 다 끝나면
      // console.log(v); // 부모 출력하고
      answer += String(v);
      DFS(v * 2 + 1); // 오른쪽 자식으로 가고
    }
  }
  DFS(n);
  return answer;
}

console.log(solution(1));
